计算机与操作系统概论/介绍

  计算机硬件系统
    存储程序计算机（冯诺依曼体系）
    总线
      内部总线（CPU内部）、系统总线（连接CPU、存储器、外设）、通信总线（计算机系统之间通信、网络）
    CPU
      ALU、Register、CTL
    存储器（层次）
      寄存器->L1/L2/L3 cache->SSD->Disk->Web、分布式文件系统
    外设
      分类：输入、输出、存储、通信；字节、字符、块
      控制方式：轮询、中断（CPU控制读写数据）、DMA（DMA控制读写数据）

  计算机软件系统
    系统软件（OS，实用程序，语言处理程序，DBMS）
    支撑软件（开发工具）
    应用软件
    
    计算机硬件系统		机器语言
    操作系统（硬件资源管理）	机器语言+广义指令
    操作系统之文件系统	机器语言+系统调用
    数据库管理系统		数据库语言
    语言处理系统		高级语言
    支撑软件		。。。

  计算机操作技术的发展
    1 原始开关/控制台
    2 装入程序，将机器语言程序装入内存（卡带/纸带）
    3 引入汇编语言，符号化机器语言
    4 批处理。引入作业控制语言，用户可编写作业说明书，成批输入作业
    5 多道程序同时运行，实现程序的切换

  计算机操作系统
    操作系统的组成：
      进程调度、进程通信、内存管理、设备管理、文件管理、网络通信、作业控制
    几类操作系统：
      多道批处理（脱机控制方式）、分时（交互控制方式）、实时
    资源管理的角度：
      资源：处理器、内存、设备、信息资源管理（文件等）、信号量资源（进程间通信）
      屏蔽资源底层的使用细节：使用驱动程序，屏蔽底层细节，向其他部分提供一个抽象的、通用的接口
      资源的共享与分配：
        资源共享方式：独占、并发
        资源分配策略：静态、动态、抢占

    控制程序执行的角度：
      多道程序设计，并发使用CPU
      实现：进程
        如何使用资源：调用操作系统提供的服务例程（陷入操作系统）
        如何复用CPU：进程调度
        如何使CPU与I/O设备充分并行：设备控制器与“通道（专门的I/O处理器）”
        如何让正在运行的程序让出CPU：中断

    控制计算机的角度：
      OS提供：操作接口（系统/命令程序）、作业级接口

    人机交互的角度：
      热点！！！

    程序接口的角度：
      程序接口：系统调用——访问操作系统的接口，完成某种特定功能的过程
      系统调用的实现：
        机制：陷入处理机制；陷入指令（引起处理器终端的制定）；对系统调用编号，约定好存放参数的寄存器
        要点：编写系统调用处理程序、系统调用入口地址表、开辟现场保护区（以保存发生系统调用时的处理器现场）

    系统结构的角度：
      模块化、层次化、虚拟化
      OS构件：内核、进程、现成、管程
      单内核、微内核、混合内核、外内核


处理器管理

  处理器与寄存器
    处理器及其部件：
      ALU、IR、ID、PC、标志寄存器flag、内存地址寄存器MAR、内存数据寄存器MDR、IO地址寄存器、IO数据寄存器；
      使用“地址、数据、控制信号”与内存或其他资源交互
    用户程序可见寄存器：
      数据寄存器：AX、BX、CX、DX（通用寄存器）
      地址寄存器：SI、DI（通用寄存器，索引）；SP、BP（通用寄存器，栈指针）；段地址（通用寄存器，CS、DS、SS、ES）
      控制与状态寄存器：PC、IR（指令寄存器）、条件码CC、flag（中断相关的位、处理器模式位、内存保护位）
    程序状态字（PSW）：
      操作系统概念：指记录当前程序运行的动态信息，通常包含（PC、IR、CC、flag）
      计算机系统的寄存器：通常设置一组控制与状态寄存器或专门的PSW寄存器

  指令与处理器模式
    指令：流水线、特权与非特权指令
    处理器模式位：实现特权指令管理
      一般情况：0操作系统内核、1系统调用、2共享库程序、3用户程序（一般只用0和3）
    模式切换：用户和内核态切换
      只有中断、异常、系统异常（请求os服务）可以由用户态切换到内核态
      中断返回指令：返回至用户模式

  中断：
    操作系统是“中断驱动”的（广义的中断）
    狭义的中断：I/O中断、时钟中断、外部信号中断
    广义的中断：
      异常：地址异常、算术异常
      系统异常：执行陷入指令而触发系统调用引起的中断事件
    中断源：
      外中断：即由外部设备、接口卡引起的中断
      内中断：即程序运行错误引起的中断
      软件中断：由写在程序中的语句引起的中断程序的执行，称为软件中断

  中断系统：
    包括硬件子系统（响应）和软件子系统（处理）
    中断响应处理：
      在指令执行周期中加入一个检查中断阶段（在取指、解码、执行后）
      外中断：中断控制器（中断控制逻辑线路和中断寄存器）
      内中断：CPU内部线路发现，陷阱
      系统异常：陷入指令触发，系统陷阱
    中断响应过程：
      发现中断源：中断寄存器中的请求——是否屏蔽——响应最优先的
      中断当前程序：保存当前的PSW/PC到进程的核心栈（保护硬件现场）
      转向os中断处理程序
    中断处理程序：
      （开始前，置PSW为操作系统内核的PSW，启动操作系统内核中断处理程序，实现硬件到软件的切换）
      保护未被硬件保护的CPU现场（cache？其它寄存器）
      分析被中断进程的PSW，识别中断源
      处理中断
      软件恢复现场（原进程或其他进程）
      硬件恢复PSW
    多中断的响应与处理
      中断屏蔽：中断屏蔽位，有选择的响应
      中断优先级：有优先度的响应（各类中断：CPU硬件故障中断、自愿性中断、程序性中断、时钟中断等外部中断、I/O中断、重启/关机中断）
      中断的嵌套处理：一般3层内，响应与处理顺序可以不一样了，改变了中断处理顺序
      多中断的响应与处理

  进程及其概念
    进程：一个具有一定独立功能的程序关于某个数据集合的一次运行活动
    进程时os进行资源分配和调度的一个独立单位
    进程包括：
      数据结构P（进程控制块PCB之类的，os管理运行程序的）
      内存代码C
      内存数据D
      通用寄存器信息R
      程序状态字信息PSW
    进程状态：运行态、等待态、就绪态、挂起等待态、挂起就绪态
    进程挂起：挂起时没有任何资源！该进程被调入OS管理的对换区，不参与进程调度；待适当时重新调入内存

  进程的数据描述
    进程控制块（PCB）：os用于记录和刻画进程状态及环境信息的数据结构
      标识信息：进程标识
      现场信息：用户可见寄存器内容、控制/状态寄存器内容、用户/核心栈指针
      控制信息：进程调度相关信息（状态、等待事件、优先级）、进程程序/数据地址、进程队列指引元（进程队列指针、父子兄弟进程指针）、进程通信相关信息（消息对列、信号量、锁）、进程处理器使用信息（占用的CPU、时间片、已执行总时间、记账信息）、进程特权信息（内存访问权限、处理器权限）、进程资源清单（占有、使用的资源）
    进程的内存映像（Process Image）：
      进程控制块、进程程序块、进程数据块、核心栈（进程在内核模式下运行时使用的堆栈，中断或系统过程使用）、共享地址空间
    进程上下文（Process）
      用户级上下文：用户程序块/用户数据区/用户栈/用户共享内存
      寄存器上下文：PSW/栈指针/通用寄存器
      系统级上下文：PCB/内存区表/核心栈

  进程的管理
    概念级的OS进程管理软件：系统调用/中断/异常处理、队列管理、进程控制、进程调度、进程通信、终端登录/作业控制、性能监控、审计
    队列模型：
      就绪队列、等待事件1/2/3队列
      FIFO或优先级队列
    进程控制与管理：
      创建、撤销、阻塞、唤醒、挂起、激活、其他
    进程控制原语
      进程控制过程中涉及对OS核心数据结构的修改

  进程切换与模式切换
    模式切换：
      用户->内核——中断/异常/系统调用，基本任务：
        处理器模式转为内核模式
        保存当前进程的PC/PSW到当前进程的核心栈
        转向中断/异常/系统调用处理程序
      内核->用户——中断返回指令，基本任务：
        从待运行进程核心栈中弹出PSW/PC值
        处理器模式转为用户模式
    进程切换：收回、分配处理器；实质上是被中断运行进程与待运行进程的上下文切换
      工作过程：
        正向模式切换（进入内核模式，压入PSW/PC）
        保存被中断进程的现场
        处理具体中断/异常
        把被中断进程的SP保存到PCB
        调整被中断进程的PCB
        把被中断进程的PCB加入相关队列
        ==========选择下一个占用CPU的进程==========
        修改新进程的PCB
        设置被选中进程的地址空间，恢复存储管理信息
        恢复SP至寄存器中
        恢复现场
        逆向模式转换（返回用户模式，弹出PSW/PC）

  多线程
    多线程环境下，进程是操作系统进行《保护》和《资源分配》的独立单位
      资源分配：容纳进程映像的虚拟地址空间
      保护：对进程、文件和设备的存取保护机制
    线程是调度的基本单位
      线程具有独立的：线程执行状态、受保护的线程上下文、PC、执行堆栈、容纳局部变量的静态存储器
      线程共享进程获得的主存空间和资源
    KLT和ULT：
      内核级多线程KLT
        OS内核直接调度KLT，管理线程
        OS提供API供开发者使用KLT
        多处理器环境中，内核能同时调度统一进程的多个线程并行执行
        线程调度需要进行模式切换，在内核模式完成
      用户级多线程ULT（想想python的多“线程”）
        用语言带的线程库，在用户空间运行
        内核没意识到线程的存在，逻辑上并发
        节省模式切换开销
        用户自定义调度算法
        可移植性高
        不能利用多处理器的优点，OS只能调度进程而非每个ULT（一个ULT代表一个进程），物理上并行性差
      Jacketing程序将内核调度转化为用户调度
    多线程的实现的混合式策略
      ULT与KLT多对多绑定
      KLT状态：可运行态、运行态、阻塞态
      ULT状态：可运行态、活跃态（对应KLT的状态）、睡眠态

  处理器调度的层次
    高级调度（长程调度）:决定能否加入到执行的进程池中
    中级调度（平衡负载调度）:决定哪个可用进程占用CPU（挂起？）
    低级调度（短程调度）:决定主存中的可用进程集合（新建后挂起？）
    高级调度介绍：
      分时OS中，高级调度决定：是否接受一个终端用户的连接、命令是否被接纳形成进程、新建态进程是否加入就绪队列？
      批处理：选取《后备》作业加入主存？为作业做准备、善后

  处理器调度算法
    原则：
      资源利用率（CPU和其他资源）
      响应时间
      周转时间（提交给系统开始到执行完的时间）
      吞吐量（单位时间处理的进程数量）
      公平性
    算法：
      优先数调度算法
      时间片轮转调度算法
      分级调度算法
        多个不同优先级队列，不同优先级的时间片长短不同
      彩票调度算法
        为进程发放针对系统各种资源（如CPU时间）的彩票，当需要做出决策时，随机选择一张彩票，看谁中奖
        合作进程之间的彩票交换


存储管理

  存储管理的主要模式
    逻辑地址（相对地址，用户编程用）：一维（地址）、二维（段号、段内地址）
      段式程序设计：把一个程序设计成多个段（代码段、数据段、堆栈段等）
    物理地址（程序执行用）：处理器执行指令时按照物理地址进行
    复用：分区复用（固定/可变尺寸）、页架复用（页架固定大小）
    存储管理的基本模式：
      单连续存储管理：一维逻辑地址空间的程序占用一个主存固定或可变分区
      段式存储管理：段式二维逻辑地址空间的程序占用多个主存可变分区
      页式存储管理：一维逻辑地址空间的程序占用多个主存页架区
      段页式存储管理：段式二维逻辑地址空间的程序占用多个主存页架区

  存储管理的功能：
    地址转换：
      静态：装入程序做
      动态：依赖硬件地址转换机构
    主存分配：
      分配主存，设置主存分配表
    主存共享：
      多个进程共享主存、多个进程共享主存的某些区域
    存储保护：
      避免多个进程相互干扰
      需要软硬件协同完成
    主存扩充（重要思想！）：
      把磁盘作为主存扩充，需要软硬件协作完成
      对换技术：把部分不运行的进程调出（对换进程决定对换，硬件机构调入）
      虚拟技术：只调入进程的部分内容（CPU发出虚拟地址异常，OS将需要的部分调入，重执指令）

  虚拟存储器：
    依据：程序执行具有局部性
    基本思想：进程先放辅存中，各部分随用随调入内存；主存中的随用随调出

  存储器的硬件支撑
    管理主存、cache（高速存储器+联想存储器+地址转换部件+替换部件）、虚拟存储
    联想存储器：根据内容进行寻址的存储器
    L1 L2 L3

  单连续分区存储管理
    每个进程占用一个物理上完全连续的存储空间，分为：
      单用户连续分区存储管理（单用户单任务，静态重定位（也就是装入时就进行了地址转换））
      固定分区存储管理（存在内零头）
      可变分区存储管理（按需分配连续空间）
        已分配区表、未分配区表
        适应分配算法：最先、邻近、最优（找最小的，容易产生外零头）、最坏（找最大的）
        移动技术（程序浮动技术）：尽量解决外零头
    单连续分区的 地址转换与存储保护
      通过《基址寄存器+逻辑地址》实现地址转换
      通过比较 《基址寄存器+逻辑地址》与 《限长寄存器》实现存储保护
        若越界，触发越界中断
      显然，需要硬件配合

  页式存储管理
    基本原理：将主存划分为多个大小相等的页架，程序的逻辑地址也自然分成页，需要页表
    逻辑地址=页号||单元号  物理地址=页架号||单元号
    地址转换：页号->页架号，通过查阅页表即可
    内存分配：用位示图，每一位代表一个页
    页的共享：数据共享（共享数据段，在不同进程的眼里，页号可以不同）；程序共享（共享代码段，在不同进程的眼里，页号必须相同）

  页式存储管理的地址转换
    朴素情况：页表放在主存，每次地址转换访问两次主存
    解决办法：利用cache存放部分页表（快表，使用联想存储器）
    多道程序下的地址转换（用进程表）：
      多道程序环境下的《进程表》中登记了《每个进程》的《页表》
      进程占有处理器运行时，其《页表起始地址》和《页表长度》送入《页表控制寄存器》

  页式虚拟存储管理
    页可放在辅存上
    页式虚拟存储的页表扩充：
      需要扩充页表项：每页的虚拟地址、实际地址、各标志位（主存驻留？写回？保护？引用？可移动？）
    实现：缺页中断

  页面调度
    选择合适的页淘汰，避免抖动/颠簸
    算法：
      OPT（最佳）：理想状况，淘汰不再用的
      FIFO
      LRU（最近最少用）：淘汰最近一段时间较久未被访问的（代价有点大，不好模拟，用页引用标志位）
      LFU（最不常用）：淘汰最近一段时间内访问次数较少的页面（比LRU好模拟）
      CLOCK（时钟调度算法）：
        页面开始被调入主存/被访问时，引用标志位置为1
        淘汰页面时，指针滑动
        碰到1的页，置为0并跳过
        碰到0的页，淘汰，继续

  反置页表（IPT）：
    MMU（内存管理单元）：
      提供地址转换与存储保护、必要时确定淘汰页面，要使用反置页表
    针对内存中的每个页架建立的页表，表项包含：
      正在访问该页架的进程标识
      虚页号（与进程标识共同确定 该进程的部分逻辑地址空间）
      特征位（有效、引用、修改、保护、锁定等）
      哈希链指针、
    基于反置页表的地址转换过程：
      （逻辑地址->物理地址）
      MMU通过哈希表把进程标识和虚页号转换为一个哈希值，指向IPT的一个表目
      遍历哈希链找到所需进程的虚页号，该项的索引就是页架号，拼接生成物理地址
      若遍历未找到，缺页中断
      MMU实行缺页中断

  段式存储管理
    （用户可以将）程序分为若干段，每段从0开始编址
    逻辑地址：段号||单元号
    基本思想：
      硬件增加一组用户可见的段地址寄存器（代码段、数据段、堆栈段、附加段），供地址转换使用
      段表：每个段表项包括《段始址、段限长、存储保护位、可移动位、可扩充位》等
    地址转换：
      从《段表控制寄存器》中得到当前段表
      按段号查段表
      得到所需段的起址和段长
      比较逻辑地址中的单元号和段长，若越界，产生越界中断，反之拼接得到绝对地址
    段的共享
      不同进程的段表中的项只向同一个段基址来实现
      需要对共享段进行保护
    段式虚拟存储管理
      段可放在辅存上
      段表扩充：
        主存始址、限长、辅存始址、各种标志/特征/扩充/存储权限位
      地址转换：
        段中断（实现虚存）：调入所需段，改段表，必要时调整内存，移出不要的段
        越界中断：若段可扩充，扩充之，改段表，必要时调整内存，移出不要的段
        之后按正常流程（查段表）实现地址转换

  段页式存储管理
    基本思想：每一段不必占据连续的存储空间，可存放在不连续的主存页架中
    地址转换：
      段表：不再记录各段的基址和限长，而是记录各段所对应的页表的基址和页表长度
      页表：每一段都有一个页表
      地址转换流程：
        输入逻辑地址
        先根据段号、页号查快表，若命中直接得到物理地址
        若快表未命中，查段表，根据段号，找到该段对应的页表
        在页表中，根据页号，找到物理块号
        （若页号越界，存储保护）
        拼接块号||单元号，得到物理地址
    虚拟存储管理：
      装入部分段，或者装入段中部分页面
      地址转换：
        在上述的地址转换中，加入缺段中断和缺页中断


设备管理

  设备管理概述
    I/O设备分类
      输入/出；人机交互/存储/机机通信；字符/块/网络
      I/O操作：内存和外设间的信息传送操作
    设备管理目标：
      解决设备和CPU速度的不匹配，充分并行
      屏蔽设备的物理细节和操作过程，配置驱动程序，提供统一界面
        实现层次：抽象为《1裸设备》、《2设备文件》
    设备管理的功能：
      设备中断处理
      缓冲区管理
      设备的分配和去配
      设备驱动调度
      虚拟设备的实现
    设备管理的实现层次：
      I/O硬件：I/O设备及其接口线路、控制部件、通道
      I/O软件：系统I/O软件、用户空间I/O软件

  设备控制器（设备适配器、I/O控制器、。。。）
    I/O设备除机械部件外的电子部件，系统交互的对象
    功能：
      接受/识别CPU或channel发来的命令
      实现数据交换
      发现和记录设备及自身的状态，供CPU使用
      当控制器连接多台设备时，识别设备的地址
    设备控制器集成在主板上，不在设备里！
    组成示意：
      主机侧：
        数据线<--->数据缓冲寄存器、状态/控制字寄存器
        地址线<--->地址译码逻辑
        控制线<--->I/O控制逻辑
      设备侧（接口电缆）：
        数据、状态、控制<--->外设接口控制逻辑

  I/O控制方式
    轮询方式：
      处理器轮询时不能做其他事情，I/O未完成不推进指令流
    中断方式：
      流程：CPU向I/O控制器发送I/O命令，控制器去I/O；控制器I/O完后中断CPU；CPU进入中断处理程序，执行内存数据交换
      I/O未完成可推进指令流：
        若该进程支持异步I/O，后续可继续该进程
        若该进程不支持异步I/O，挂起该进程，CPU执行其他工作
      中断，实现数据交换，仍然是CPU执行数据交换
    DMA（直接存储器访问）方式：
      控制器而非CPU执行数据交换
      流程：CPU向控制器DMA模块发出I/O命令；CPU不做内存数据交换，由DMA一并完成；DMA传送完数据后再中断CPU；CPU中断，读DMA状态
      DMA和CPU要竞争内存总线，但影响不大（流水线CPU执行时总有不要交换数据的时候，可以窃取这些周期）
    通道（channel）方式：
      前三种方式物理并行，CPU与通道高速并行
      I/O通道（通道控制器、I/O处理器）：是一个简单的处理器，用于完成逻辑上独立的I/O任务
      四级连接：
        处理器<----共用总线---->通道<----下级总线---->控制器、设备
        通道可控制多台同类或不同类的设备
      通道可控制多台同类或不同类的设备
      流程：
        CPU遇到I/O任务，组织通道程序，置通道程序地址字CAW，启动指定通道；CPU执行其他任务
        通道从CAW获得通道程序，控制I/O设备进行操作
        I/O通道完成I/O操作后发出中断；CPU处理中断，从通道程序状态字CSW获得通道执行情况，处理I/O操作
      CPU把I/O相关的程序（指令流）分给了channel，逻辑上并行

  总线与I/O：
    总线解决I/O速度不匹配问题，各设备I/O速度也不匹配
    经典的总线模型：
      单总线结构模型：
        一条总线，连接CPU、主存与所有I/O设备
        总线压力大
        CPU<------总线-------------------------->
                    |                   |                   |
                 主存              I/O               I/O

      三级总线模型：
        CPU内部总线（与cache）、CPU-主存总线、外设扩展总线
        优点：CPU-主存 主存-外设 分离；可支持更多外设
        缺点：不适用于I/O设备数据速率相差太大的情形
        CPU<-----局部总线----------------------->cache
                                            |                                  |
                                  局部I/O控制器                       |
                  主存                                                      |
                     |                                                         |
           <--------主存总线------------------------------>
                                               |
                                      扩展总线接口
                                               |
            <--------扩展总线------------------------------>
                   |             |                            |               |
                LAN       SCSI                  字符设备     块设备

      南北桥模型：
        CPU内部总线、主存总线、PCI总线（北桥、高速外设）、E（ISA）总线（南桥、慢速外设）
                         SCSI                     LAN                  图形设备
                            |                           |                           |
                 <------------PCI总线------------------------------>
                                                        |
           CPU<--处理总线-->北桥（主存控制器）<--存储总线-->主存
                                                        |
                                                  桥间接口
                                                        |
                                           南桥（I/O控制器）
                                                        |
                  <-------E(ISA)总线--------------------------------->      
                           |                            |                              |
                        COM                     鼠标                        键盘

      基于通道的服务器总线模型：
        有层级，有通道管控制器
            CPU<-------->主存控制器<-------->主存
                                            |
              <--------------------------------------->
                          |                                    |
                     I/O通道                         I/O通道
                          |                                    |
              <------------->             <------------->
                 |                 |                  |                  |
          I/O控制器   I/O控制器    I/O控制器   I/O控制器
                 |             。。。
         <-------->
            |         |
         设备   设备

  I/O软件：
    I/O软件的设计目标：高效率、通用性
    设计思路：软件组织成层次；低层屏蔽硬件细节、高层提供友善界面
    要考虑的问题：设备无关性、出错处理（低层错误不给高层）、同步/异步传输、缓冲技术（建立内存缓冲区）
    层次结构：
      用户空间的软件（系统调用（如sprintf等）、格式化、SPOOLing）
        库函数
        虚拟设备软件（用一类设备模拟另一类设备的仿真I/O软件）
      独立于设备的软件（逻辑功能：设备的命名、保护、阻塞 、缓冲、分配、跟踪）
      设备驱动程序（设备初始化、启动I/O操作、检查I/O状态，对应某类设备的具体细节，可以分层设计）
        处理某（类）设备密切相关的代码
        从独立于设备的软件收到请求，把逻辑I/O请求转化为物理的操作；监督出错；访问数据缓冲区
        功能：
          设备初始化：预置设备、控制器以及channel的状态
          执行设备驱动例程：启动设备数据传输；组织通道程序，启动通道工作
          执行与设备相关的具体中断处理：处理各设备、控制器、channel的具体中断
        设备驱动程序可以分层（使用一个栈，逐层调用）
      中断处理程序（处理中断、报告错误、中断时唤醒驱动程序，响应/原则处理）
        检查设备状态寄存器，判断中断原因，根据I/O情况处理：
          若出错，向上层软件报告错误原因
          若ok，唤醒等待传输的进程，使其变为就绪态
          若有等待传输的I/O命令，通知相关软件启动下一个I/O请求
      硬件（最底层）

  I/O缓冲区：
    非用户创建，而是os在内存中开辟的存储区，专门用于临时存放I/O操作的数据
    设置缓冲区的目的：
      CPU与设备速度不匹配
      逻辑/物理记录大小不一致
      提高CPU与I/O设备的并行性
      减少I/O设备对CPU的中断次数
      放宽CPU对中断响应时间的要求
    缓冲技术
      单缓冲技术
      双缓冲技术
      循环缓冲技术

  设备独立性：
    用户不指定物理设备，而是指定逻辑设备，使用户进程和物理设备分离开来
    通过其它途径建立逻辑设备和物理设备之间的映射
    系统需提供逻辑设备名和物理设备名的对应表
    易于应对各种I/O设备故障，提高系统可靠性、设备分配的灵活性

  独占型外设的分配
    独占性外设：一次只能由一个进程独占
    设备分配方式：
      静态分配：进程运行前申请
        简单，防止死锁
      动态分配（随用随分配）：
        提高设备利用率，但可能死锁
    设备分配的数据结构
      设备表
        每类设备都有各自的设备表，用来登记这类设备中的每台物理设备
        表项包括：物理设备名、逻辑设备名、占有进程、分配标志、好坏标志
      设备类表（实现设备独立性，申请外设时，申请设备类表中的一类逻辑设备）
        每类设备对应设备类表中的一栏
        表项包括：设备类、总台数、空闲台数、设备表起始地址等
        支持设备独立性时使用

  磁盘的物理结构
    磁盘结构：盘片组、盘片（两个盘面）、磁道（盘面上的一个圆环）、扇区、读写磁头、移动臂
      一些概念：簇（相邻的几个扇区）、柱面（同一轴方向上的多个盘面）
      物理块地址：柱面号、磁头号、扇区号
    磁盘的工作方式：磁头移到响应柱面（寻道），旋转扇区到磁头下（旋转），传送数据
    磁盘的读写时间：寻道时间+旋转延迟+传送时间

  磁盘的驱动调度
    背景：磁盘可能《同时接收到若干》I/O请求
    任务：OS按照磁盘调度策略，即按照最佳次序执行处理访问磁盘的多个I/O请求，以减少磁盘访问的总处理时间
    驱动调度策略包括：移臂调度、旋转调度
    移臂调度：
      FIFO：不行！拉跨！
      最短查找时间优先：容易“饥饿”，边缘磁道难得到满足
      扫描算法（单向或双向）：还行
      电梯调度：改进的扫描算法
    旋转调度：循环排序？优化I/O请求排序
    优化分布（不是算法，而是设计！通过信息在存储空间的排列方式来减少旋转延迟）：交替排序、相邻扇区集中成簇、按柱面集种存储数据

  SPOOLing系统
    虚拟设备技术：
      使用一类物理设备模拟另一类物理设备
      如：内存模拟高速磁盘，块设备模拟字符设备、输入输出重定向 
    一个经典的SPOOLing系统：
      用高速的磁盘设备模拟慢速的字符设备，缩短进程在内存中的驻留时间
      ！慢速输入到《输入井》、慢速输出到《输出井》
      进程运行时只《从/向》《输入/输出》井中《输入/输出》信息，使得全部I/O都基于磁盘
      需要：预输入程序、缓输出程序、井管理程序（实质上是I/O重定向）
      加快进程周转时间，提高系统吞吐量
      （如：主要的任务进程是吃饭，预输入进程是送饭，任务进程不再需要先装入内存等待送饭，而是在送饭到内存后，再被装入内存）
    打印SPOOLing系统：
      用唯一的一个守护进程使用打印机
      打印文件前，用户进程将带输出文件存放在打印目录下（相当于一个输出井）
      这时用户进程就可以关了，虽然还没有完成打印，但是逻辑上已经任务完成，可以腾出内存，提高吞吐率
      之后打印机空闲时，守护进程启动，打印所需文件

  批处理系统的作业管理（与SPOOLing系统）
    作业：就是一个作业的概念，需要通过创建并运行进程完成作业，比进程更“静止”的一个概念（抽象的作业需要通过运动的进程来完成）
    作业的生命周期：输入状态（预输入）、后备状态（空闲）、执行状态（进程运行）、完成状态（缓输出）
    作业调度（选中并创建进程、作业的终止和撤离）：必须要完成了预输入、资源满足才能进入运行状态（与进程调度的最大区别）


文件管理

  文件概述
    背景：
      文件和进程是os的两大重要概念
      os首先对硬件资源进行管理，模拟了一个多进程并发计算的环境，实现了os对硬件的第一次扩充
      进一步，os对进程加以计算/处理的《数据》进行了进一步的管理，引入了文件的概念
    文件的概念：
      文件是具有符号名的，在逻辑上具有完整意义的一组相关信息项的序列
    文件命名：文件名和拓展名
    文件分类：
      系统文件/库文件/用户文件
      只读/读写/不保护
      临时/永久/档案
      磁盘/磁带/光盘/软盘0
    引入文件的优点
      用户使用方便
      文件安全可靠
      文件可备份
      文件可共享

  文件系统及其功能
    文件系统的概念
      os中负责《存取和管理信息》的模块
      用《统一的方式》管理用户和系统信息的存储、检索、更新、共享和保护
      《为用户提供》一整套方便有效的文件《使用和操作方法》
    文件系统中的文件
      逻辑结构and存储结构
      同一个文件须从逻辑文件和物理文件两个侧面来观察它
    文件系统的功能
      文件的《按名存取》、《共享、保护》、《操作和使用》
      os需考虑：
        文件目录的建立和维护
        存储空间的分配和回收
        数据的保密和保护
        监督用户存取和修改文件的权限
        实现在不同存储介质上信息的表示方式、编址方法、存储次序、信息检索等问题
    文件系统的组成
      文件的组织：
        逻辑结构（对用户）：流式文件、记录式文件
        物理结构：顺序文件、连接文件、直接文件、索引文件
      文件的存取
        顺序存取
        随机存取：直接存取、索引存取
      文件的控制
        逻辑/物理的控制系统
      文件的使用
        文件操作：打开/关闭/读/写/控制文件

  文件存储
    卷和块
      文件存储介质有磁带、光盘和磁盘
      卷是存储介质的物理单位
      块是存储介质上连续信息所组成的一个区域，也叫做物理记录
      块在主存储器和辅助存储器进行信息交换的物理单位
      块（机械）之间留有间隙
    顺序存取存储设备
      严格依赖信息的物理位置（一维）次序进行定位和读写的存储设备
      磁带机、光盘
    直接存取存储设备（随机存取存储设备）
      （不需要在一个一维空间上顺序地移动读写头）
      存取任何一个物理块所需的时间几乎不依赖于此信息的位置
      磁盘：移臂和旋转（二维），不是一维的

  文件的逻辑结构
    逻辑文件（文件的逻辑结构）：
      独立于物理环境的，用户概念中的抽象信息组织方式
      用户能观察到的，并加以处理的数据集合
    流式文件（基于字节）：
      文件中的数据不再组成记录，只是由《一串依次的字节》组成的信息流序列
      按长度来读取所需信息，也可以用插入的特殊字符（比如回车符）作为分界
    记录式文件（基于记录）
      一种有结构的文件，是由若干逻辑记录信息所组成的记录流文件
      逻辑记录：文件中按信息在逻辑上的独立含义所划分的信息单位（比如：每个职工的工资信息是一个逻辑记录，整个单位职工的工资信息加起来成了一个记录式文件）
    记录式文件与数据库的区别
      数据库中的记录之间可以构成联系（JOIN），并支持基于联系的数据查询（FROM）
      文件系统不支持JOIN！

  文件的物理结构（物理文件）
    文件在物理存储空间中的存放方法和组织关系
    涉及：块的划分、记录的排列、索引的组织、信息的搜索等许多问题
    顺序文件
      将一个文件中逻辑上连续的信息，存放到存储介质《依此相邻的块》中
      比如：磁带文件、光盘文件
      优点：顺序存取记录时速度较快（比如批处理文件、系统文件）
      缺点：建立文件需预知文件长度；修改、插入、增加文件记录有困难
    连接文件
      解决顺序文件的缺点
      使用连接字来表示文件中各个物理块之间的先后次序
      第一块物理地址由文件目录给出，每一块的连接字指出了文件的下一个物理块；连接字内容为0时，文件结束
      输入井、输出井文件
      优点：易于增删改，存储空间利用率高
      缺点：指针消耗额外空间（微弱）；不能随机读写（需要遍历链表）！
    直接文件（散列文件）
      通过计算记录的关键字，建立与其物理存储地址之间的对应关系
      解决冲突的办法：拉链法、循环探查法、二次散列法、溢出区法 等
    索引文件      
      为每个文件建立一张索引表，记录每个逻辑记录号与存储地址之间的对应关系
      索引表的地址可由文件目录指出
      索引文件分为索引区和数据区
      访问索引文件两步：先查找索引表，获得逻辑记录物理地址，再访问该逻辑记录
      特点（意义）：可理解为连接文件的拓展（索引表相当于连接字的集中存放），而索引表又是顺序结构改造的
      优点：os较多使用，综合顺序文件、连接文件的优点，比较快速的随机访问，便于增删改
      缺点：增加了索引表的空间开销和查找时间
      索引表可组织为多级索引（每级索引都有）

  文件目录的结构
    文件目录需要永久保存，因此也《组织成文件》存放在磁盘上，称为目录文件
    树形目录结构
  文件目录的管理
    文件查找：按路径名查找文件
      每层子目录都要访问辅存，往往需要多次访问辅存，虽然可以把目录信息放进主存但代价较大
      只把正在处理的文件目录信息放进主存（使用活动文件表）
    活动文件表：
      os可以为每个用户进程建立一张活动文件表
      当用户使用一个文件之前，先执行“打开”操作：
        把该文件有关目录信息复制到制定《主存》区域
        把有关信息填入活动文件表，以建立用户进程和该文件索引的联系
      当不再使用文件时，“关闭”：
        切断用户进程和这个文件的联系
        若该目录已经被修改过，更新辅存中对应的文件目录

  文件的安全与保护
    文件共享
      不同用户共同使用某些文件
      减少复制，省空间
      文件共享的并发控制：
        多进程同时读：对文件进行公用控制
        有写操作：必须提供同步控制机制，以保证文件数据的完整性，不允许同时写
    文件保密
      防止文件及其内容被其他用户窃取
      隐蔽文件、口令、加密
    文件保护
      防止文件被破坏（具体见下节），保证文件完整性
  文件保护
    防止文件被破坏（具体见下节），保证文件完整性
    常用方法：文件副本、文件存取矩阵与文件存取表、文件属性
    文件副本：
      动态多副本技术
        在多个介质上维持同一内容的文件，并且在更新内容时同时进行
        比较麻烦、精细
      转储、备份与恢复
        定期把文件复制转储到其他介质上，当某介质上出现故障时，复原转储文件
    文件的存取控制矩阵
      存取属性：访问、读、写、执行、创建、删除、授权（变更存取属性的权利）等
      os为每个用户设置访问每个文件对象的存取属性
      系统的全部用户对全部文件的存取属性就组成了一个二维矩阵
      是一个稀疏矩阵，可以简化为一张存取控制表
      存取控制表：
        每行包括：用户、文件、存取属性
      os通过查阅（矩阵/表），核对用户对文件的存取权限      
      文件属性：
        用户分类：属主、合作者、其他
        文件属性：读、写、执行
        文件属性直接放在文件目录项中，管理大为简化

  文件的存取方法
    顺序存取方法：
      按记录顺序进行读/写操作的存取方法
      对于各种物理结构的文件都使用
      os必须提供读/写指针，允许指针前跳/后退的定位操作
    直接存取方法：
      快速地以任意次序直接读写某个记录
    索引存取方法：
      基于索引文件的索引存取方法

  文件的使用
    用户通过两类接口与文件系统联系：
      与文件有关的操作命令：cat, cd, cp, find等
      os提供给用户使用的文件类系统调用：fopen
    建立文件：建立一个文件。在相应设备上建立文件目录项，为文件分配第一个物理块，在活动文件表中申请一个项，返回一个文件句柄
    撤销文件：删除一个文件。若文件未关闭，先关闭文件；若为共享文件，进行联访处理；在目录文件中删去相应目录项；释放文件占用的空间  
    打开文件：建立文件和用户进程的使用联系。在活动文件表中申请一个项，返回一个文件句柄；把目录信息复制到活动文件表相应栏；检查访问的合法性；处理共享
    关闭文件：使用一个文件句柄关闭。将活动文件表中该文件的“当前使用用户数”减1；若此值为0，则收回此活动文件表；完成“推迟写”；若有必要，修改文件目录结构
    读写文件：根据文件句柄，修改文件
    定位文件：调整读写指针位置

  辅存空间管理
    随着用户文件不断建立和撤销，文件存储空间会出现许多“碎片”
    os需要整理“碎片”，往往对文件重新组织，让其存放在连续存储区中
    辅存空间的分配方式：
      连续分配：优点是顺序访问时速度快，管理较为简单；但需管理碎片
      非连续分配：辅存空间管理效率高，便于文件动态增长和收缩
    管理空闲块：
      使用位示图，1占用，0空闲，或更多位标志坏块
      使用连接指针中的位
    空闲块成组连接法！

  文件系统的实现层次（上至底）
    用户接口
      接受用户发来的系统调用，进行语法检查，进入逻辑文件控制子系统
    逻辑文件控制子系统
      根据文件路径名，搜索文件目录，建立活动文件表
      根据文件结构和存取方法，把逻辑记录转换成相对物理块号和块内相对地址
    文件保护子系统
      识别调用者的身份，验证存取权限，判定本次文件操作的合法性
    物理文件控制子系统
      实现缓冲区管理
      根据物理结构，将相对物理块号转换为实际物理块号
      负责文件存储空间的分配
      生成I/O控制系统的调用形式
    I/O控制子系统
      执行具体的物理块I/O操作


并发程序设计

  并发程序设计的概念
    顺序程序设计
      程序执行的内部顺序性：程序在处理器上执行是严格有序的
      程序执行的外部顺序性：程序设计的一般习惯是顺序程序设计，把一个具体问题的求解过程设计成一个《程序（或若干严格顺序执行的程序序列）》
      特性：
        程序执行的顺序性
        计算环境的封闭性（程序运行时如同独占受操作系统保护的资源）
        计算结果的确定性
        计算过程的可再见性
    进程的并发执行
      os保证按照“顺序程序设计”方法编制的程序在并发执行时不受影响，如同独占计算机
    并发程序设计
      把一个具体问题求解设计成若干个可同时执行的程序模块的方法
      特性：
        并行性（提高计算效率）：多个进程在多道程序系统中并发执行或者在多处理器系统中并行执行
        共享性：多个进程共享软件资源
        交往性（增加程序设计难度）：多个进程并发执行时存在制约

  并发进程的制约关系
    无关的并发进程：一组并发进程分别在不同的变量集合上运行，一个进程的执行与其他并发进程的进展无关
    交往的并发进程：一组并发进程共享某些变量，一个进程的执行可能影响其他并发进程的结果
    与时间有关的错误：
      对于一组交往的并发进程，执行的相对速度无法相互控制
      表现：结果错误、永远等待
    进程互斥：
      并发进程之间因相互争夺独占性资源（共享变量也算）而产生的竞争制约关系
    进程同步：
      并发进程之间为完成共同任务，基于某个条件来协调执行先后关系而产生的协作制约关系
      比如必须先输入进程，再计算进程

  临界区
    临界资源：
      互斥共享变量所代表的资源
      一次只能被一个进程使用的资源
    临界区：
      并发进程中与互斥共享变量相关的程序段
      如果两个进程同时停留再相关的临界区内，就会出现与时间相关的错误
    临界区的描述：
      确定临界资源
      确定临界区
      如：
        shard x, y;
        region x do {
          ...
          region y do {
            ..
          }
        }
      两个进程的临界区有《相同》的临界资源，就是相关的临界区
    临界区管理的三个要求
      一次至多允许一个进程停留在相关的临界区内
      一个进程不能无限止地停留在临界区内
      一个进程不能无限止地等待进入临界区（不能饿死）
    临界区的嵌套使用
      要对临界资源排序，按级别次序申请

  临界区管理实现的尝试
    测试锁、建立锁两条指令不能中断
    测试并建立指令
  临界区管理实现的硬件方式
    TS：测试并建立锁指令
    swap：对换指令（对换两个变量的值）
    上述方法未解决的问题：忙式等待，占用CPU，效率低
     操作系统原语（不建议用户使用）：
       屏蔽中断->临界区->打开中断
       不可滥用！拉低效率！

  PV操作与进程互斥
    问题：TS或swap忙式等待，效率低；关开中断管理临界区不便用户使用
    解决方案：
      参考：就像进程申请硬件资源一样的流程，即 请求->进入等待队列->得到资源出队列&恢复就绪态
      方案：信号量、PV原语
    信号量：
      核心数据结构：等待进程队列
      信号量声明：资源报道，建立队列
      申请资源的原语：若申请不得，调用进程入队等待
      归还资源的原语：若队列中有等待进程，需释放
      信号量撤销：资源注销，撤销队列
    记录型信号量：
      typedef struct semaphore {
        int value; // 信号量值，正值表示可复用次数，0表示无资源且无进程等待，负值表示等待队列中的进程个数
        struct pcb *list;  //信号量等待进程队列指针
      }
      每个信号量建立一个等待进程队列
    PV操作原语：
      P原语（申请资源）
      P(semaphore:s) {
        s = s - 1;
        if (s < 0) wait(s);
      }
      V原语（归还资源）
      V(semaphore:s){
        s = s + 1;
        if (s <= 0) release(s); //释放一个等待信号量s的进程 
      }
    PV操作进程互斥问题框架
      semaphore s;
      s = 1;
      cobegin
        process Pi{
          ...
          P(s);
          临界区;
          V(s);
          ...
        }
      coend;
    注意：P操作和V操作在执行路径上一定要《一一匹配》
      
  PV操作与进程同步
    生产者消费者问题
    process producer {
      L1:
      produce a product;
      P(sput);
      B = product;
      V(sget);
      goto L1;
    }
    process consumer {
      L2:
      P(sget);
      Product = B;
      V(sput);
      consume a product;
      goto L2;
    }
    多生产者多消费者多缓冲区？
    苹果橘子问题

  管程（Monitor）概述
    管程概念的提出
      管程试图：抽象相关并发进程对共享变量的访问
      管程：由若干公共变量及其说明，和所有访问这些变量的过程所组成
        管程把分散在各个进程中互斥地访问公共变量的那些临界区集中起来管理
        管程的局部变量只能由该管程的过程存取
        进程只能互斥地调用管程中的过程（只能有一个进程调用管程）
        对管程的实现由编译器完成，如java的synchronized
        管程可以看做一个软件模块,它是将共享的变量和对于这些共享变量的操作封装起来,形成一个具有一定接口的功能模块
    管程的基本形式
      TYPE<管程名> = MONITOR
        <管程变量说明>
        define <（能被其他模块引用的）过程名列表>
        use <（要引用的模块外定义的）过程名列表>
        procedure<过程名>（形参表）
          begin
            <过程体>
          end
        ......
        procedure<过程名>（形参表）
          begin
            <过程体>
          end
      begin
        <管程的局部数据初始化语句>
      end
    管程的条件变量：
      条件变量：一种信号量。当调用管程过程的进程无法运行时，用于阻塞进程的信号量
      同步原语wait：当一个管程过程发现无法继续时，它在某些条件变量上执行wait，进程阻塞
      同步原语signal：用于释放在条件变量上阻塞的进程
    管程的执行模型
      等待调用管程进程队列（互斥）
                       |
                    入口
                       |
                    管程
      同步所用队列：条件变量队列、条件变量对列、...、互斥调用管程过程高优先级队列（signal归还处）

  霍尔管程及其实现
    实现思路：
      使用signal释放一个等待进程时，霍尔管程让执行signal的进程等待，直到被释放进程退出管程或等待另一个条件
    霍尔管程基于PV操作原语实现
      wait和signal可以是程序过程（不需要是原语）
      可以用语言机制实现霍尔管程（不需要os提供什么原语，只需要os程序库或高级程序语言，在基础的os的PV原语上做出来，而不需要拓展os内核）
    实现：
      互斥调用霍尔管程的信号量及整数变量：
      TYPE interf = RECORD;
        mutex : semaphore; //调用管程过程前使用的互斥信号量
        next : semaphore;  //发出signal的进程挂起自己的信号量
        next_count : int; //在next上等待的进程数
      条件变量及整数变量：
        x_sem : semaphore; //与资源相关的信号量
        x_count : int; //在x_sem上等待的进程数
      procedure wait(var x_sem : semaphore, var x_count : int, var IM : interf)
        begin
          x_count = x_count + 1;
          if IM.next_count > 0 then
            V(IM.next);
          else
            V(IM.mutex);
          P(x_sem);
          x_count = x_count - 1;
        end
      procedure signal(var x_sem : semaphore, var x_count : int, var IM : interf)
        begin
          if x_count > 0 then
          begin
            IM.next_count = IM.next_count + 1;
            V(x_sem);
            P(IM.next); //自己被挂起
            IM.next_count = IM.next_count - 1;
          end
        end
    为实现互斥使用管程的过程，调用管程过程的标准程序框架如下：
      P(IM.mutex); //先获得管程的互斥锁
      <调用管程的过程>
      if IM.next_count > 0 then V(IM.next); else V(IM.mutex); //唤醒管程中的就绪进程，或归还互斥锁使新进程加入管程

  霍尔管程的例子
    把PV编程变简单！
    哲学家问题
      5个哲学家围一圈，5个叉子放桌上，每人左右手各一个；每个哲学家思考，饥饿，然后吃，要两只手都有叉子才能吃
    读者写者问题
      有两组并发进程：读者与写者，共享一个文件，要求：
        允许多个读者同时读；
        任意写者出现后，新的读者与写者均被拒绝；
        写者在完成写操作之前不允许其他读者和写者工作；
        写者欲工作，要等待已存在的读者完成读；

  进程通信
    信号量操作是一种低级通信方式
    进程需要交换更多的信息，引进进程通信机制，实现用《信件》来交换信息，扩充并发进程的数据共享
    进程直接通信：
      直接指出发送给谁/从哪接受
      send(P, 信件) //把信件发送给进程P
      receive(Q, 信件) //从进程Q接受信件
    进程间接通信
      发送或者接受信件通过一个信箱来进行，该信箱有唯一标识符
      多个进程共享一个信箱
        send(A, 信件) //把信件传送到信箱A
        receive(A, 信件) //从信箱A接收信件
      信箱：分为信箱特征和信箱体
        信箱特征：信箱容量、信件格式、指针等
        信箱体：存放信件（分成若干个区，每个区容纳一封信）
      间接通信的原语：
        发送信件：
          若指定的信箱未满，把信件送入信箱中指针所指示的位置，释放等待该信箱中信件的等待着
          否则，发送者等待信箱
        接收信件：
          若指定信箱中有信件，取出一封信件，释放等待信箱的等待者
          否则，接收者等待信件

  高级进程通信机制
    基于字节流的通信规约
      多个进程使用一个共享的消息缓冲区（可称为管道、多路转接器、套接字）
      写入（send/write），读出（receive/read）
    基于RPC（Remote Process Calling）的高级通信规约
      客户/服务器计算模式
      服务器提供《过程/服务》
      客户调用服务器《过程/服务》
      注意需要外部数据表示XDR（传输时的中间数据表示）

  死锁的产生
    死锁：每一个进程都在等待被另一个进程所占有的、不能抢占的资源
    死锁产生例子：
      竞争资源产生死锁
      PV操作不当
      同类资源分配不当
      对临时性资源使用不加限制
      ...
    解决死锁的三个方面：
      死锁防止
      死锁避免
      死锁检测和恢复
  死锁的防止

