计算机与操作系统概论/介绍

  计算机硬件系统
    存储程序计算机（冯诺依曼体系）
    总线
      内部总线（CPU内部）、系统总线（连接CPU、存储器、外设）、通信总线（计算机系统之间通信、网络）
    CPU
      ALU、Register、CTL
    存储器（层次）
      寄存器->L1/L2/L3 cache->SSD->Disk->Web、分布式文件系统
    外设
      分类：输入、输出、存储、通信；字节、字符、块
      控制方式：轮询、中断（CPU控制读写数据）、DMA（DMA控制读写数据）

  计算机软件系统
    系统软件（OS，实用程序，语言处理程序，DBMS）
    支撑软件（开发工具）
    应用软件
    
    计算机硬件系统		机器语言
    操作系统（硬件资源管理）	机器语言+广义指令
    操作系统之文件系统	机器语言+系统调用
    数据库管理系统		数据库语言
    语言处理系统		高级语言
    支撑软件		。。。

  计算机操作技术的发展
    1 原始开关/控制台
    2 装入程序，将机器语言程序装入内存（卡带/纸带）
    3 引入汇编语言，符号化机器语言
    4 批处理。引入作业控制语言，用户可编写作业说明书，成批输入作业
    5 多道程序同时运行，实现程序的切换

  计算机操作系统
    操作系统的组成：
      进程调度、进程通信、内存管理、设备管理、文件管理、网络通信、作业控制
    几类操作系统：
      多道批处理（脱机控制方式）、分时（交互控制方式）、实时
    资源管理的角度：
      资源：处理器、内存、设备、信息资源管理（文件等）、信号量资源（进程间通信）
      屏蔽资源底层的使用细节：使用驱动程序，屏蔽底层细节，向其他部分提供一个抽象的、通用的接口
      资源的共享与分配：
        资源共享方式：独占、并发
        资源分配策略：静态、动态、抢占

    控制程序执行的角度：
      多道程序设计，并发使用CPU
      实现：进程
        如何使用资源：调用操作系统提供的服务例程（陷入操作系统）
        如何复用CPU：进程调度
        如何使CPU与I/O设备充分并行：设备控制器与“通道（专门的I/O处理器）”
        如何让正在运行的程序让出CPU：中断

    控制计算机的角度：
      OS提供：操作接口（系统/命令程序）、作业级接口

    人机交互的角度：
      热点！！！

    程序接口的角度：
      程序接口：系统调用——访问操作系统的接口，完成某种特定功能的过程
      系统调用的实现：
        机制：陷入处理机制；陷入指令（引起处理器终端的制定）；对系统调用编号，约定好存放参数的寄存器
        要点：编写系统调用处理程序、系统调用入口地址表、开辟现场保护区（以保存发生系统调用时的处理器现场）

    系统结构的角度：
      模块化、层次化、虚拟化
      OS构件：内核、进程、现成、管程
      单内核、微内核、混合内核、外内核


处理器管理

  处理器与寄存器
    处理器及其部件：
      ALU、IR、ID、PC、标志寄存器flag、内存地址寄存器MAR、内存数据寄存器MDR、IO地址寄存器、IO数据寄存器；
      使用“地址、数据、控制信号”与内存或其他资源交互
    用户程序可见寄存器：
      数据寄存器：AX、BX、CX、DX（通用寄存器）
      地址寄存器：SI、DI（通用寄存器，索引）；SP、BP（通用寄存器，栈指针）；段地址（通用寄存器，CS、DS、SS、ES）
      控制与状态寄存器：PC、IR（指令寄存器）、条件码CC、flag（中断相关的位、处理器模式位、内存保护位）
    程序状态字（PSW）：
      操作系统概念：指记录当前程序运行的动态信息，通常包含（PC、IR、CC、flag）
      计算机系统的寄存器：通常设置一组控制与状态寄存器或专门的PSW寄存器

  指令与处理器模式
    指令：流水线、特权与非特权指令
    处理器模式位：实现特权指令管理
      一般情况：0操作系统内核、1系统调用、2共享库程序、3用户程序（一般只用0和3）
    模式切换：用户和内核态切换
      只有中断、异常、系统异常（请求os服务）可以由用户态切换到内核态
      中断返回指令：返回至用户模式

  中断：
    操作系统是“中断驱动”的（广义的中断）
    狭义的中断：I/O中断、时钟中断、外部信号中断
    广义的中断：
      异常：地址异常、算术异常
      系统异常：执行陷入指令而触发系统调用引起的中断事件
    中断源：
      外中断：即由外部设备、接口卡引起的中断
      内中断：即程序运行错误引起的中断
      软件中断：由写在程序中的语句引起的中断程序的执行，称为软件中断

  中断系统：
    包括硬件子系统（响应）和软件子系统（处理）
    中断响应处理：
      在指令执行周期中加入一个检查中断阶段（在取指、解码、执行后）
      外中断：中断控制器（中断控制逻辑线路和中断寄存器）
      内中断：CPU内部线路发现，陷阱
      系统异常：陷入指令触发，系统陷阱
    中断响应过程：
      发现中断源：中断寄存器中的请求——是否屏蔽——响应最优先的
      中断当前程序：保存当前的PSW/PC到进程的核心栈（保护硬件现场）
      转向os中断处理程序
    中断处理程序：
      （开始前，置PSW为操作系统内核的PSW，启动操作系统内核中断处理程序，实现硬件到软件的切换）
      保护未被硬件保护的CPU现场（cache？其它寄存器）
      分析被中断进程的PSW，识别中断源
      处理中断
      软件恢复现场（原进程或其他进程）
      硬件恢复PSW
    多中断的响应与处理
      中断屏蔽：中断屏蔽位，有选择的响应
      中断优先级：有优先度的响应（各类中断：CPU硬件故障中断、自愿性中断、程序性中断、时钟中断等外部中断、I/O中断、重启/关机中断）
      中断的嵌套处理：一般3层内，响应与处理顺序可以不一样了，改变了中断处理顺序
      多中断的响应与处理

  进程及其概念
    进程：一个具有一定独立功能的程序关于某个数据集合的一次运行活动
    进程时os进行资源分配和调度的一个独立单位
    进程包括：
      数据结构P（进程控制块PCB之类的，os管理运行程序的）
      内存代码C
      内存数据D
      通用寄存器信息R
      程序状态字信息PSW
    进程状态：运行态、等待态、就绪态、挂起等待态、挂起就绪态
    进程挂起：挂起时没有任何资源！该进程被调入OS管理的对换区，不参与进程调度；待适当时重新调入内存

  进程的数据描述
    进程控制块（PCB）：os用于记录和刻画进程状态及环境信息的数据结构
      标识信息：进程标识
      现场信息：用户可见寄存器内容、控制/状态寄存器内容、用户/核心栈指针
      控制信息：进程调度相关信息（状态、等待事件、优先级）、进程程序/数据地址、进程队列指引元（进程队列指针、父子兄弟进程指针）、进程通信相关信息（消息对列、信号量、锁）、进程处理器使用信息（占用的CPU、时间片、已执行总时间、记账信息）、进程特权信息（内存访问权限、处理器权限）、进程资源清单（占有、使用的资源）
    进程的内存映像（Process Image）：
      进程控制块、进程程序块、进程数据块、核心栈（进程在内核模式下运行时使用的堆栈，中断或系统过程使用）、共享地址空间
    进程上下文（Process）
      用户级上下文：用户程序块/用户数据区/用户栈/用户共享内存
      寄存器上下文：PSW/栈指针/通用寄存器
      系统级上下文：PCB/内存区表/核心栈

  进程的管理
    概念级的OS进程管理软件：系统调用/中断/异常处理、队列管理、进程控制、进程调度、进程通信、终端登录/作业控制、性能监控、审计
    队列模型：
      就绪队列、等待事件1/2/3队列
      FIFO或优先级队列
    进程控制与管理：
      创建、撤销、阻塞、唤醒、挂起、激活、其他
    进程控制原语
      进程控制过程中涉及对OS核心数据结构的修改

  进程切换与模式切换
    模式切换：
      用户->内核——中断/异常/系统调用，基本任务：
        处理器模式转为内核模式
        保存当前进程的PC/PSW到当前进程的核心栈
        转向中断/异常/系统调用处理程序
      内核->用户——中断返回指令，基本任务：
        从待运行进程核心栈中弹出PSW/PC值
        处理器模式转为用户模式
    进程切换：收回、分配处理器；实质上是被中断运行进程与待运行进程的上下文切换
      工作过程：
        正向模式切换（进入内核模式，压入PSW/PC）
        保存被中断进程的现场
        处理具体中断/异常
        把被中断进程的SP保存到PCB
        调整被中断进程的PCB
        把被中断进程的PCB加入相关队列
        ==========选择下一个占用CPU的进程==========
        修改新进程的PCB
        设置被选中进程的地址空间，恢复存储管理信息
        恢复SP至寄存器中
        恢复现场
        逆向模式转换（返回用户模式，弹出PSW/PC）

  多线程
    多线程环境下，进程是操作系统进行《保护》和《资源分配》的独立单位
      资源分配：容纳进程映像的虚拟地址空间
      保护：对进程、文件和设备的存取保护机制
    线程是调度的基本单位
      线程具有独立的：线程执行状态、受保护的线程上下文、PC、执行堆栈、容纳局部变量的静态存储器
      线程共享进程获得的主存空间和资源
    KLT和ULT：
      内核级多线程KLT
        OS内核直接调度KLT，管理线程
        OS提供API供开发者使用KLT
        多处理器环境中，内核能同时调度统一进程的多个线程并行执行
        线程调度需要进行模式切换，在内核模式完成
      用户级多线程ULT（想想python的多“线程”）
        用语言带的线程库，在用户空间运行
        内核没意识到线程的存在，逻辑上并发
        节省模式切换开销
        用户自定义调度算法
        可移植性高
        不能利用多处理器的优点，OS只能调度进程而非每个ULT（一个ULT代表一个进程），物理上并行性差
      Jacketing程序将内核调度转化为用户调度
    多线程的实现的混合式策略
      ULT与KLT多对多绑定
      KLT状态：可运行态、运行态、阻塞态
      ULT状态：可运行态、活跃态（对应KLT的状态）、睡眠态

  处理器调度的层次
    高级调度（长程调度）:决定能否加入到执行的进程池中
    中级调度（平衡负载调度）:决定哪个可用进程占用CPU（挂起？）
    低级调度（短程调度）:决定主存中的可用进程集合（新建后挂起？）
    高级调度介绍：
      分时OS中，高级调度决定：是否接受一个终端用户的连接、命令是否被接纳形成进程、新建态进程是否加入就绪队列？
      批处理：选取《后备》作业加入主存？为作业做准备、善后

  处理器调度算法
    原则：
      资源利用率（CPU和其他资源）
      响应时间
      周转时间（提交给系统开始到执行完的时间）
      吞吐量（单位时间处理的进程数量）
      公平性
    算法：
      优先数调度算法
      时间片轮转调度算法
      分级调度算法
        多个不同优先级队列，不同优先级的时间片长短不同
      彩票调度算法
        为进程发放针对系统各种资源（如CPU时间）的彩票，当需要做出决策时，随机选择一张彩票，看谁中奖
        合作进程之间的彩票交换


存储管理

  存储管理的主要模式
    逻辑地址（相对地址，用户编程用）：一维（地址）、二维（段号、段内地址）
      段式程序设计：把一个程序设计成多个段（代码段、数据段、堆栈段等）
    物理地址（程序执行用）：处理器执行指令时按照物理地址进行
    复用：分区复用（固定/可变尺寸）、页架复用（页架固定大小）
    存储管理的基本模式：
      单连续存储管理：一维逻辑地址空间的程序占用一个主存固定或可变分区
      段式存储管理：段式二维逻辑地址空间的程序占用多个主存可变分区
      页式存储管理：一维逻辑地址空间的程序占用多个主存页架区
      段页式存储管理：段式二维逻辑地址空间的程序占用多个主存页架区

  存储管理的功能：
    地址转换：
      静态：装入程序做
      动态：依赖硬件地址转换机构
    主存分配：
      分配主存，设置主存分配表
    主存共享：
      多个进程共享主存、多个进程共享主存的某些区域
    存储保护：
      避免多个进程相互干扰
      需要软硬件协同完成
    主存扩充（重要思想！）：
      把磁盘作为主存扩充，需要软硬件协作完成
      对换技术：把部分不运行的进程调出（对换进程决定对换，硬件机构调入）
      虚拟技术：只调入进程的部分内容（CPU发出虚拟地址异常，OS将需要的部分调入，重执指令）

  虚拟存储器：
    依据：程序执行具有局部性
    基本思想：进程先放辅存中，各部分随用随调入内存；主存中的随用随调出

  存储器的硬件支撑
    管理主存、cache（高速存储器+联想存储器+地址转换部件+替换部件）、虚拟存储
    联想存储器：根据内容进行寻址的存储器
    L1 L2 L3

  单连续分区存储管理
    每个进程占用一个物理上完全连续的存储空间，分为：
      单用户连续分区存储管理（单用户单任务，静态重定位（也就是装入时就进行了地址转换））
      固定分区存储管理（存在内零头）
      可变分区存储管理（按需分配连续空间）
        已分配区表、未分配区表
        适应分配算法：最先、邻近、最优（找最小的，容易产生外零头）、最坏（找最大的）
        移动技术（程序浮动技术）：尽量解决外零头
    单连续分区的 地址转换与存储保护
      通过《基址寄存器+逻辑地址》实现地址转换
      通过比较 《基址寄存器+逻辑地址》与 《限长寄存器》实现存储保护
        若越界，触发越界中断
      显然，需要硬件配合

  页式存储管理
    基本原理：将主存划分为多个大小相等的页架，程序的逻辑地址也自然分成页，需要页表
    逻辑地址=页号||单元号  物理地址=页架号||单元号
    地址转换：页号->页架号，通过查阅页表即可
    内存分配：用位示图，每一位代表一个页
    页的共享：数据共享（共享数据段，在不同进程的眼里，页号可以不同）；程序共享（共享代码段，在不同进程的眼里，页号必须相同）

  页式存储管理的地址转换
    朴素情况：页表放在主存，每次地址转换访问两次主存
    解决办法：利用cache存放部分页表（快表，使用联想存储器）
    多道程序下的地址转换（用进程表）：
      多道程序环境下的《进程表》中登记了《每个进程》的《页表》
      进程占有处理器运行时，其《页表起始地址》和《页表长度》送入《页表控制寄存器》

  页式虚拟存储管理
    页可放在辅存上
    页式虚拟存储的页表扩充：
      需要扩充页表项：每页的虚拟地址、实际地址、各标志位（主存驻留？写回？保护？引用？可移动？）
    实现：缺页中断

  页面调度
    选择合适的页淘汰，避免抖动/颠簸
    算法：
      OPT（最佳）：理想状况，淘汰不再用的
      FIFO
      LRU（最近最少用）：淘汰最近一段时间较久未被访问的（代价有点大，不好模拟，用页引用标志位）
      LFU（最不常用）：淘汰最近一段时间内访问次数较少的页面（比LRU好模拟）
      CLOCK（时钟调度算法）：
        页面开始被调入主存/被访问时，引用标志位置为1
        淘汰页面时，指针滑动
        碰到1的页，置为0并跳过
        碰到0的页，淘汰，继续

  反置页表（IPT）：
    MMU（内存管理单元）：
      提供地址转换与存储保护、必要时确定淘汰页面，要使用反置页表
    针对内存中的每个页架建立的页表，表项包含：
      正在访问该页架的进程标识
      虚页号（与进程标识共同确定 该进程的部分逻辑地址空间）
      特征位（有效、引用、修改、保护、锁定等）
      哈希链指针、
    基于反置页表的地址转换过程：
      （逻辑地址->物理地址）
      MMU通过哈希表把进程标识和虚页号转换为一个哈希值，指向IPT的一个表目
      遍历哈希链找到所需进程的虚页号，该项的索引就是页架号，拼接生成物理地址
      若遍历未找到，缺页中断
      MMU实行缺页中断

  段式存储管理
    （用户可以将）程序分为若干段，每段从0开始编址
    逻辑地址：段号||单元号
    基本思想：
      硬件增加一组用户可见的段地址寄存器（代码段、数据段、堆栈段、附加段），供地址转换使用
      段表：每个段表项包括《段始址、段限长、存储保护位、可移动位、可扩充位》等
    地址转换：
      从《段表控制寄存器》中得到当前段表
      按段号查段表
      得到所需段的起址和段长
      比较逻辑地址中的单元号和段长，若越界，产生越界中断，反之拼接得到绝对地址
    段的共享
      不同进程的段表中的项只向同一个段基址来实现
      需要对共享段进行保护
    段式虚拟存储管理
      段可放在辅存上
      段表扩充：
        主存始址、限长、辅存始址、各种标志/特征/扩充/存储权限位
      地址转换：
        段中断（实现虚存）：调入所需段，改段表，必要时调整内存，移出不要的段
        越界中断：若段可扩充，扩充之，改段表，必要时调整内存，移出不要的段
        之后按正常流程（查段表）实现地址转换

  段页式存储管理
    基本思想：每一段不必占据连续的存储空间，可存放在不连续的主存页架中
    地址转换：
      段表：不再记录各段的基址和限长，而是记录各段所对应的页表的基址和页表长度
      页表：每一段都有一个页表
      地址转换流程：
        输入逻辑地址
        先根据段号、页号查快表，若命中直接得到物理地址
        若快表未命中，查段表，根据段号，找到该段对应的页表
        在页表中，根据页号，找到物理块号
        （若页号越界，存储保护）
        拼接块号||单元号，得到物理地址
    虚拟存储管理：
      装入部分段，或者装入段中部分页面
      地址转换：
        在上述的地址转换中，加入缺段中断和缺页中断


设备管理

  设备管理概述
    I/O设备分类
      输入/出；人机交互/存储/机机通信；字符/块/网络
      I/O操作：内存和外设间的信息传送操作
    设备管理目标：
      解决设备和CPU速度的不匹配，充分并行
      屏蔽设备的物理细节和操作过程，配置驱动程序，提供统一界面
        实现层次：抽象为《1裸设备》、《2设备文件》
    设备管理的功能：
      设备中断处理
      缓冲区管理
      设备的分配和去配
      设备驱动调度
      虚拟设备的实现
    设备管理的实现层次：
      I/O硬件：I/O设备及其接口线路、控制部件、通道
      I/O软件：系统I/O软件、用户空间I/O软件

  设备控制器（设备适配器、I/O控制器、。。。）
    I/O设备除机械部件外的电子部件，系统交互的对象
    功能：
      接受/识别CPU或channel发来的命令
      实现数据交换
      发现和记录设备及自身的状态，供CPU使用
      当控制器连接多台设备时，识别设备的地址
    设备控制器集成在主板上，不在设备里！
    组成示意：
      主机侧：
        数据线<--->数据缓冲寄存器、状态/控制字寄存器
        地址线<--->地址译码逻辑
        控制线<--->I/O控制逻辑
      设备侧（接口电缆）：
        数据、状态、控制<--->外设接口控制逻辑

  I/O控制方式
    轮询方式：
      处理器轮询时不能做其他事情，I/O未完成不推进指令流
    中断方式：
      流程：CPU向I/O控制器发送I/O命令，控制器去I/O；控制器I/O完后中断CPU；CPU进入中断处理程序，执行内存数据交换
      I/O未完成可推进指令流：
        若该进程支持异步I/O，后续可继续该进程
        若该进程不支持异步I/O，挂起该进程，CPU执行其他工作
      中断，实现数据交换，仍然是CPU执行数据交换
    DMA（直接存储器访问）方式：
      控制器而非CPU执行数据交换
      流程：CPU向控制器DMA模块发出I/O命令；CPU不做内存数据交换，由DMA一并完成；DMA传送完数据后再中断CPU；CPU中断，读DMA状态
      DMA和CPU要竞争内存总线，但影响不大（流水线CPU执行时总有不要交换数据的时候，可以窃取这些周期）
    通道（channel）方式：
      前三种方式物理并行，CPU与通道高速并行
      I/O通道（通道控制器、I/O处理器）：是一个简单的处理器，用于完成逻辑上独立的I/O任务
      四级连接：
        处理器<----共用总线---->通道<----下级总线---->控制器、设备
        通道可控制多台同类或不同类的设备
      通道可控制多台同类或不同类的设备
      流程：
        CPU遇到I/O任务，组织通道程序，置通道程序地址字CAW，启动指定通道；CPU执行其他任务
        通道从CAW获得通道程序，控制I/O设备进行操作
        I/O通道完成I/O操作后发出中断；CPU处理中断，从通道程序状态字CSW获得通道执行情况，处理I/O操作
      CPU把I/O相关的程序（指令流）分给了channel，逻辑上并行

  总线与I/O：
    总线解决I/O速度不匹配问题，各设备I/O速度也不匹配
    经典的总线模型：
      单总线结构模型：
        一条总线，连接CPU、主存与所有I/O设备
        总线压力大
        CPU<------总线-------------------------->
                    |                   |                   |
                 主存              I/O               I/O

      三级总线模型：
        CPU内部总线（与cache）、CPU-主存总线、外设扩展总线
        优点：CPU-主存 主存-外设 分离；可支持更多外设
        缺点：不适用于I/O设备数据速率相差太大的情形
        CPU<-----局部总线----------------------->cache
                                            |                                  |
                                  局部I/O控制器                       |
                  主存                                                      |
                     |                                                         |
           <--------主存总线------------------------------>
                                               |
                                      扩展总线接口
                                               |
            <--------扩展总线------------------------------>
                   |             |                            |               |
                LAN       SCSI                  字符设备     块设备

      南北桥模型：
        CPU内部总线、主存总线、PCI总线（北桥、高速外设）、E（ISA）总线（南桥、慢速外设）
                         SCSI                     LAN                  图形设备
                            |                           |                           |
                 <------------PCI总线------------------------------>
                                                        |
           CPU<--处理总线-->北桥（主存控制器）<--存储总线-->主存
                                                        |
                                                  桥间接口
                                                        |
                                           南桥（I/O控制器）
                                                        |
                  <-------E(ISA)总线--------------------------------->      
                           |                            |                              |
                        COM                     鼠标                        键盘

      基于通道的服务器总线模型：
        有层级，有通道管控制器
            CPU<-------->主存控制器<-------->主存
                                            |
              <--------------------------------------->
                          |                                    |
                     I/O通道                         I/O通道
                          |                                    |
              <------------->             <------------->
                 |                 |                  |                  |
          I/O控制器   I/O控制器    I/O控制器   I/O控制器
                 |             。。。
         <-------->
            |         |
         设备   设备

  I/O软件：
    I/O软件的设计目标：高效率、通用性
    设计思路：软件组织成层次；低层屏蔽硬件细节、高层提供友善界面
    要考虑的问题：设备无关性、出错处理（低层错误不给高层）、同步/异步传输、缓冲技术（建立内存缓冲区）
    层次结构：
      用户空间的软件（系统调用（如sprintf等）、格式化、SPOOLing）
        库函数
        虚拟设备软件（用一类设备模拟另一类设备的仿真I/O软件）
      独立于设备的软件（逻辑功能：设备的命名、保护、阻塞 、缓冲、分配、跟踪）
      设备驱动程序（设备初始化、启动I/O操作、检查I/O状态，对应某类设备的具体细节，可以分层设计）
        处理某（类）设备密切相关的代码
        从独立于设备的软件收到请求，把逻辑I/O请求转化为物理的操作；监督出错；访问数据缓冲区
        功能：
          设备初始化：预置设备、控制器以及channel的状态
          执行设备驱动例程：启动设备数据传输；组织通道程序，启动通道工作
          执行与设备相关的具体中断处理：处理各设备、控制器、channel的具体中断
        设备驱动程序可以分层（使用一个栈，逐层调用）
      中断处理程序（处理中断、报告错误、中断时唤醒驱动程序，响应/原则处理）
        检查设备状态寄存器，判断中断原因，根据I/O情况处理：
          若出错，向上层软件报告错误原因
          若ok，唤醒等待传输的进程，使其变为就绪态
          若有等待传输的I/O命令，通知相关软件启动下一个I/O请求
      硬件（最底层）

  I/O缓冲区：
    非用户创建，而是os在内存中开辟的存储区，专门用于临时存放I/O操作的数据
    设置缓冲区的目的：
      CPU与设备速度不匹配
      逻辑/物理记录大小不一致
      提高CPU与I/O设备的并行性
      减少I/O设备对CPU的中断次数
      放宽CPU对中断响应时间的要求
    缓冲技术
      单缓冲技术
      双缓冲技术
      循环缓冲技术

  设备独立性：
    用户不指定物理设备，而是指定逻辑设备，使用户进程和物理设备分离开来
    通过其它途径建立逻辑设备和物理设备之间的映射
    系统需提供逻辑设备名和物理设备名的对应表
    易于应对各种I/O设备故障，提高系统可靠性、设备分配的灵活性

  独占型外设的分配
    独占性外设：一次只能由一个进程独占
    设备分配方式：
      静态分配：进程运行前申请
        简单，防止死锁
      动态分配（随用随分配）：
        提高设备利用率，但可能死锁
    设备分配的数据结构
      设备表
        每类设备都有各自的设备表，用来登记这类设备中的每台物理设备
        表项包括：物理设备名、逻辑设备名、占有进程、分配标志、好坏标志
      设备类表（实现设备独立性，申请外设时，申请设备类表中的一类逻辑设备）
        每类设备对应设备类表中的一栏
        表项包括：设备类、总台数、空闲台数、设备表起始地址等
        支持设备独立性时使用

  磁盘的物理结构
    磁盘结构：盘片组、盘片（两个盘面）、磁道（盘面上的一个圆环）、扇区、读写磁头、移动臂
      一些概念：簇（相邻的几个扇区）、柱面（同一轴方向上的多个盘面）
      物理块地址：柱面号、磁头号、扇区号
    磁盘的工作方式：磁头移到响应柱面（寻道），旋转扇区到磁头下（旋转），传送数据
    磁盘的读写时间：寻道时间+旋转延迟+传送时间

  磁盘的驱动调度
    背景：磁盘可能《同时接收到若干》I/O请求
    任务：OS按照磁盘调度策略，即按照最佳次序执行处理访问磁盘的多个I/O请求，以减少磁盘访问的总处理时间
    驱动调度策略包括：移臂调度、旋转调度
    移臂调度：
      FIFO：不行！拉跨！
      最短查找时间优先：容易“饥饿”，边缘磁道难得到满足
      扫描算法（单向或双向）：还行
      电梯调度：改进的扫描算法
    旋转调度：循环排序？优化I/O请求排序
    优化分布（不是算法，而是设计！通过信息在存储空间的排列方式来减少旋转延迟）：交替排序、相邻扇区集中成簇、按柱面集种存储数据

  SPOOLing系统
    虚拟设备技术：
      使用一类物理设备模拟另一类物理设备
      如：内存模拟高速磁盘，块设备模拟字符设备、输入输出重定向 
    一个经典的SPOOLing系统：
      用高速的磁盘设备模拟慢速的字符设备，缩短进程在内存中的驻留时间
      ！慢速输入到《输入井》、慢速输出到《输出井》
      进程运行时只《从/向》《输入/输出》井中《输入/输出》信息，使得全部I/O都基于磁盘
      需要：预输入程序、缓输出程序、井管理程序（实质上是I/O重定向）
      加快进程周转时间，提高系统吞吐量
      （如：主要的任务进程是吃饭，预输入进程是送饭，任务进程不再需要先装入内存等待送饭，而是在送饭到内存后，再被装入内存）
    打印SPOOLing系统：
      用唯一的一个守护进程使用打印机
      打印文件前，用户进程将带输出文件存放在打印目录下（相当于一个输出井）
      这时用户进程就可以关了，虽然还没有完成打印，但是逻辑上已经任务完成，可以腾出内存，提高吞吐率
      之后打印机空闲时，守护进程启动，打印所需文件

  批处理系统的作业管理（与SPOOLing系统）
    作业：就是一个作业的概念，需要通过创建并运行进程完成作业，比进程更“静止”的一个概念（抽象的作业需要通过运动的进程来完成）
    作业的生命周期：输入状态（预输入）、后备状态（空闲）、执行状态（进程运行）、完成状态（缓输出）
    作业调度（选中并创建进程、作业的终止和撤离）：必须要完成了预输入、资源满足才能进入运行状态（与进程调度的最大区别）


文件管理

  文件概述
    背景：
      文件和进程是os的两大重要概念
      os首先对硬件资源进行管理，模拟了一个多进程并发计算的环境，实现了os对硬件的第一次扩充
      进一步，os对进程加以计算/处理的《数据》进行了进一步的管理，引入了文件的概念
    文件的概念：
      文件是具有符号名的，在逻辑上具有完整意义的一组相关信息项的序列
    文件命名：文件名和拓展名
    文件分类：
      系统文件/库文件/用户文件
      只读/读写/不保护
      临时/永久/档案
      磁盘/磁带/光盘/软盘0
    引入文件的优点
      用户使用方便
      文件安全可靠
      文件可备份
      文件可共享

  文件系统及其功能
    文件系统的概念
      os中负责《存取和管理信息》的模块
      用《统一的方式》管理用户和系统信息的存储、检索、更新、共享和保护
      《为用户提供》一整套方便有效的文件《使用和操作方法》
    文件系统中的文件
      逻辑结构and存储结构
      同一个文件须从逻辑文件和物理文件两个侧面来观察它
    文件系统的功能
      文件的《按名存取》、《共享、保护》、《操作和使用》
      os需考虑：
        文件目录的建立和维护
        存储空间的分配和回收
        数据的保密和保护
        监督用户存取和修改文件的权限
        实现在不同存储介质上信息的表示方式、编址方法、存储次序、信息检索等问题
    文件系统的组成
      文件的组织：
        逻辑结构（对用户）：流式文件、记录式文件
        物理结构：顺序文件、连接文件、直接文件、索引文件
      文件的存取
        顺序存取
        随机存取：直接存取、索引存取
      文件的控制
        逻辑/物理的控制系统
      文件的使用
        文件操作：打开/关闭/读/写/控制文件

  文件存储
    卷和块
      文件存储介质有磁带、光盘和磁盘
      卷是存储介质的物理单位
      块是存储介质上连续信息所组成的一个区域，也叫做物理记录
      块在主存储器和辅助存储器进行信息交换的物理单位
      块（机械）之间留有间隙
    顺序存取存储设备
      严格依赖信息的物理位置（一维）次序进行定位和读写的存储设备
      磁带机、光盘
    直接存取存储设备（随机存取存储设备）
      （不需要在一个一维空间上顺序地移动读写头）
      存取任何一个物理块所需的时间几乎不依赖于此信息的位置
      磁盘：移臂和旋转（二维），不是一维的

  文件的逻辑结构
    逻辑文件（文件的逻辑结构）：
      独立于物理环境的，用户概念中的抽象信息组织方式
      用户能观察到的，并加以处理的数据集合
    流式文件（基于字节）：
      文件中的数据不再组成记录，只是由《一串依次的字节》组成的信息流序列
      按长度来读取所需信息，也可以用插入的特殊字符（比如回车符）作为分界
    记录式文件（基于记录）
      一种有结构的文件，是由若干逻辑记录信息所组成的记录流文件
      逻辑记录：文件中按信息在逻辑上的独立含义所划分的信息单位（比如：每个职工的工资信息是一个逻辑记录，整个单位职工的工资信息加起来成了一个记录式文件）
    记录式文件与数据库的区别
      数据库中的记录之间可以构成联系（JOIN），并支持基于联系的数据查询（FROM）
      文件系统不支持JOIN！

  文件的物理结构（物理文件）
    文件在物理存储空间中的存放方法和组织关系
    涉及：块的划分、记录的排列、索引的组织、信息的搜索等许多问题
    顺序文件
      将一个文件中逻辑上连续的信息，存放到存储介质《依此相邻的块》中
      比如：磁带文件、光盘文件
      优点：顺序存取记录时速度较快（比如批处理文件、系统文件）
      缺点：建立文件需预知文件长度；修改、插入、增加文件记录有困难
    连接文件
      解决顺序文件的缺点
      使用连接字来表示文件中各个物理块之间的先后次序
      第一块物理地址由文件目录给出，每一块的连接字指出了文件的下一个物理块；连接字内容为0时，文件结束
      输入井、输出井文件
      优点：易于增删改，存储空间利用率高
      缺点：指针消耗额外空间（微弱）；不能随机读写（需要遍历链表）！
    直接文件（散列文件）
      通过计算记录的关键字，建立与其物理存储地址之间的对应关系
      解决冲突的办法：拉链法、循环探查法、二次散列法、溢出区法 等
    索引文件      
      为每个文件建立一张索引表，记录每个逻辑记录号与存储地址之间的对应关系
      索引表的地址可由文件目录指出
      索引文件分为索引区和数据区
      访问索引文件两步：先查找索引表，获得逻辑记录物理地址，再访问该逻辑记录
      特点（意义）：可理解为连接文件的拓展（索引表相当于连接字的集中存放），而索引表又是顺序结构改造的
      优点：os较多使用，综合顺序文件、连接文件的优点，比较快速的随机访问，便于增删改
      缺点：增加了索引表的空间开销和查找时间
      索引表可组织为多级索引（每级索引都有）






